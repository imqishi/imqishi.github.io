<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>数学/数字类问题汇总 | Nick's Recycle bin</title><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"><script>var GLOBAL = { 
  root: '/',
  algolia: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><link rel="icon" href="/favicon.ico"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode-319-Bulb-Switcher"><span class="toc-number">1.</span> <span class="toc-text">Leetcode 319 Bulb Switcher</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode-357-Count-Numbers-with-Unique-Digits"><span class="toc-number">2.</span> <span class="toc-text">Leetcode 357 Count Numbers with Unique Digits</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode-365-Water-and-Jug-Problem"><span class="toc-number">3.</span> <span class="toc-text">Leetcode 365 Water and Jug Problem</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#裴蜀定理-摘自Wikipedia"><span class="toc-number">3.1.</span> <span class="toc-text">裴蜀定理 - 摘自Wikipedia</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#思路"><span class="toc-number">3.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代码"><span class="toc-number">3.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode-372-Super-Pow"><span class="toc-number">4.</span> <span class="toc-text">Leetcode 372. Super Pow</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目"><span class="toc-number">4.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#思路-1"><span class="toc-number">4.2.</span> <span class="toc-text">思路</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode-371-Sum-of-Two-Integers"><span class="toc-number">5.</span> <span class="toc-text">Leetcode 371. Sum of Two Integers</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目-1"><span class="toc-number">5.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#思路-2"><span class="toc-number">5.2.</span> <span class="toc-text">思路</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode-172-Factorial-Trailing-Zeroes"><span class="toc-number">6.</span> <span class="toc-text">Leetcode 172 Factorial Trailing Zeroes</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Leetcode-386-Lexicographical-Numbers"><span class="toc-number">6.1.</span> <span class="toc-text">Leetcode 386. Lexicographical Numbers</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode-390-Elimination-Game"><span class="toc-number">7.</span> <span class="toc-text">Leetcode 390. Elimination Game</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode-396-Rotate-Function"><span class="toc-number">8.</span> <span class="toc-text">Leetcode 396. Rotate Function</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode-397-Integer-Replacement"><span class="toc-number">9.</span> <span class="toc-text">Leetcode 397. Integer Replacement</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode-400-Nth-Digit"><span class="toc-number">10.</span> <span class="toc-text">Leetcode 400. Nth Digit</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode-402-Remove-K-Digits"><span class="toc-number">11.</span> <span class="toc-text">Leetcode 402. Remove K Digits</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#其他"><span class="toc-number">12.</span> <span class="toc-text">其他</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="img/avatar.jpg"></div><div class="author-info__name text-center">Nick</div><div class="author-info__description text-center">弱者 总是为他们的失败找理由 而他们本身就是最好的理由</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">53</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">22</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container" style="background-image: url(true);"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Nick's Recycle bin</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">数学/数字类问题汇总</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-04-27 </time></div></div></div><div class="layout" id="content-inner"><article id="post"><div id="post-content"><h1 id="Leetcode-319-Bulb-Switcher"><a href="#Leetcode-319-Bulb-Switcher" class="headerlink" title="Leetcode 319 Bulb Switcher"></a>Leetcode 319 Bulb Switcher</h1><p>给一个n表示有n个灯泡，开始它们是全部关闭的，之后会分别以每隔0-n-1个的次序把灯泡状态取反，求最后有几个灯泡开着。比如，每隔0个把灯泡状态取反，就是全开着，每隔1个把灯泡状态取反，就是0 2 4 6 …关闭，其他的开启。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Given n = 3. </div><div class="line"></div><div class="line">At first, the three bulbs are [off, off, off].</div><div class="line">After first round, the three bulbs are [on, on, on].</div><div class="line">After second round, the three bulbs are [on, off, on].</div><div class="line">After third round, the three bulbs are [on, off, off]. </div><div class="line"></div><div class="line">So you should return 1, because there is only one bulb is on.</div></pre></td></tr></table></figure>
<p>首先观察题目给的例子，多写几个可以发现，<strong>一个开关i被拨动的次数就是i的约数的个数</strong>，比如第8个开关，它被拨动了4次，分别在轮数为1, 2, 4, 8时，而1, 2, 4, 8就是8的约数。<br>所以题目就变成了求1-n中每个数i的约数个数，统计约数个数是奇数的数目，因为如果约数个数是奇数，则开关是开的。<br>那么下一步就是求i的约数个数，我们注意到，<strong>约数是成对存在的</strong>，即2是8的约数，那么8÷2=4也是8的约数，其中有一种特殊情况，就是i为完全平方数，比如9跟它的约数3，因此，<br><strong>如果i是完全平方数，那么i的约数个数肯定是奇数，如果i不是完全平方数，由于约数成对出现，所以约数个数肯定是偶数。</strong><br>于是题目转化为：<strong>计算1-n中完全平方数的数目</strong></p>
<p>而<strong>小于等于n的平方数的数目就是直接对n的平方根取整数</strong>，所以直接返回对n的平方根的取整即可。</p>
<h1 id="Leetcode-357-Count-Numbers-with-Unique-Digits"><a href="#Leetcode-357-Count-Numbers-with-Unique-Digits" class="headerlink" title="Leetcode 357 Count Numbers with Unique Digits"></a>Leetcode 357 Count Numbers with Unique Digits</h1><p>给出一个非负整数n，计算 0 &lt;= i &lt; 10^n 所有位都不同的数字有多少个。</p>
<p>这其实是一个排列组合问题。</p>
<p>首先我们考虑一位数，可以有0 - 9共10个</p>
<p>然后考虑2位数，第一位数字可以取 1 - 9 共9个，对于第一位已经确定的数字，第二位保证与其不同有9个可能，所以一共是9 * 9 = 81个</p>
<p>然后考虑3位数，同样的方法得到前两位的取值，此时还剩下8个数字可以选，所以是 9 <em> 9 </em> 8 个</p>
<p>4位数：9 <em> 9 </em> 8 * 7</p>
<p>以此类推…注意到，当位数多于10以后必然会出现重的数字，因此只需计算到10位即可</p>
<p>显然我们要求和就是把上述各种位数的结果加起来。易得代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNumbersWithUniqueDigits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> sum = <span class="number">10</span>, last = <span class="number">9</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n &amp;&amp; i &lt;= <span class="number">10</span>; i ++) &#123;</div><div class="line">        last = last * (<span class="number">9</span> - i + <span class="number">2</span>);</div><div class="line">        sum += last;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Leetcode-365-Water-and-Jug-Problem"><a href="#Leetcode-365-Water-and-Jug-Problem" class="headerlink" title="Leetcode 365 Water and Jug Problem"></a>Leetcode 365 Water and Jug Problem</h1><p>给两个桶，分别指定他们的容量为 x 和 y。有无限量的水，判断是否能用这两个桶量出 z 数量的水。</p>
<p>离散数学里面讨论过的问题，其实是一个数论的问题，和分金条问题类似。</p>
<h2 id="裴蜀定理-摘自Wikipedia"><a href="#裴蜀定理-摘自Wikipedia" class="headerlink" title="裴蜀定理 - 摘自Wikipedia"></a>裴蜀定理 - 摘自Wikipedia</h2><p>在数论中，裴蜀等式（英语：Bézout’s identity）或裴蜀定理（Bézout’s lemma）是一个关于最大公约数（或最大公约式）的定理。裴蜀定理得名于法国数学家艾蒂安·裴蜀，说明了对任何整数  a、 b和  m，关于未知数 x 和 y的线性丢番图方程（称为裴蜀等式）：</p>
<p>ax + by = m</p>
<p>有整数解时当且仅当m是 a 及 b 的最大公约数 d 的倍数。裴蜀等式有解时必然有无穷多个整数解，每组解 x、 y都称为裴蜀数，可用扩展欧几里得算法求得。</p>
<p>特别来说，方程 ax + by = 1 有整数解当且仅当整数a和b互素。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>只需要简单的求出 x 与 y 的最大公约数，然后判断 z 是否是最大公约数的倍数即可。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">x = 4, y = 6, z = 8.</div><div class="line">GCD(4, 6) = 2</div><div class="line">8 是 2 的倍数，并且我们可以凑出：</div><div class="line">-1 * 4 + 6 * 2 = 8</div><div class="line">这种情况的意思是，可以通过倒一次4升桶，向6升桶两次注入水得到所求。过程如下：先把6升桶倒满，然后把6升桶的水倒入4升桶，把4升桶清空，把剩下的2升倒入4升桶，再把6升桶注满，就得到了8升水。</div><div class="line">其实我们可以发现，完全可以：</div><div class="line">2 * 4 + 6 * 0 = 8</div><div class="line">向4升桶注满水，然后倒入6升桶，再把4升桶倒满，就得到了8升。</div></pre></td></tr></table></figure>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canMeasureWater</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (x + y &lt; z) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (x == z || y == z || x + y == z) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> z % GCD(x, y) == <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GCD</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">    <span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">int</span> t = a % b;</div><div class="line">        a = b;</div><div class="line">        b = t;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> a;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>顺便复习一下求最大公约数，辗转相除法~</p>
<h1 id="Leetcode-372-Super-Pow"><a href="#Leetcode-372-Super-Pow" class="headerlink" title="Leetcode 372. Super Pow"></a>Leetcode 372. Super Pow</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给出一个正整数 a 和一个正整数组成的数组 b，求 a 的 b 次方对 1337 取余的结果。</p>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>最简单的思路就是对数组进行整数的模拟减法，然后一直减到0为止，每减1就做乘法和取余。这种方法的关键在于数组的整数减法模拟，比较常规的思路。</p>
<p>还有一种就是首先分析一下取余操作是个什么套路，可以发现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a * b % k = ((a % k) * (b % k)) % k</div></pre></td></tr></table></figure>
<p> n 次方这个操作到底是什么样子的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">x^n = x^p * x^q  (n = p + q)</div><div class="line">x^n = (x^p)^q  (n = p * q)</div></pre></td></tr></table></figure>
<p>我们惊奇地发现，完全可以把以数组表示的幂数采用如上的幂操作进行分解，假设我们使用 f(a, b) 表示计算 a ^ b % 1337，有如下示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">f(a, 12345) = f(f(a, 1234), 10) * f(a, 5) % 1337</div></pre></td></tr></table></figure>
<p>正好符合递归函数的定义有木有！然后就可以欢乐的写代码啦</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="keyword">int</span> BASE = <span class="number">1337</span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">superPower</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span>[] b)</span> </span>&#123;</div><div class="line">    LinkedList&lt;Integer&gt; bList = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : b) &#123;</div><div class="line">        bList.add(i);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> subSuperPower(a, bList);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subSuperPower</span><span class="params">(<span class="keyword">int</span> a, LinkedList&lt;Integer&gt; b)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (b.size() == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> last_digit = b.removeLast();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> powMod(subSuperPower(a, b), <span class="number">10</span>) * powMod(a, last_digit) % BASE;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">powMod</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    a %= BASE;</div><div class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i ++) &#123;</div><div class="line">        res = (res * a) % BASE;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Leetcode-371-Sum-of-Two-Integers"><a href="#Leetcode-371-Sum-of-Two-Integers" class="headerlink" title="Leetcode 371. Sum of Two Integers"></a>Leetcode 371. Sum of Two Integers</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>不使用 + 和 - 实现两个数字的求和操作。</p>
<h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>不让用符号，就是考你位运算…（这脑回路应该没啥问题</p>
<p>相加的操作如何完成呢？我们把数字转成二进制看，显然取与操作可以求得进位，取异或操作可以求得加和后该位应该的取值。那么我们通过一次 &amp; 操作可以取得两个数字会发生进位的位置，通过 ^ 操作进行一次不考虑进位的加和，最终把 b 改为进位的数字左移一位（因为下一轮求和时进的位是和左边一位加，所以要左移一位）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">    <span class="keyword">while</span>(b != <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">int</span> carry = a &amp; b;</div><div class="line">        a = a ^ b;</div><div class="line">        b = carry &lt;&lt; <span class="number">1</span>;            </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> a;        </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Leetcode-172-Factorial-Trailing-Zeroes"><a href="#Leetcode-172-Factorial-Trailing-Zeroes" class="headerlink" title="Leetcode 172 Factorial Trailing Zeroes"></a>Leetcode 172 Factorial Trailing Zeroes</h1><p>给一个整数n，求 n! 中尾部有多少个0。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">5! = 1 * 2 * 3 * 4 * 5 = 120</div><div class="line">So you return 1</div></pre></td></tr></table></figure>
<p>本题思路与上题类似，都是递归的思想。通过规律总结可以发现，如果末尾是0，只有 2 <em> 5 这种情况。对于25我们可以拆成 5 </em> 5，125可以拆成 5 <em> 5 </em> 5。对于 n! 来说，可以发现2的数量必然比5出现的次数多。因此我们只需要计算5出现的次数。可得代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trailingZeroes</span><span class="params">(self, n)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type n: int</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">else</span> n / <span class="number">5</span> + self.trailingZeroes(n / <span class="number">5</span>)</div><div class="line"></div><div class="line">obj = Solution()</div><div class="line"><span class="keyword">print</span> obj.trailingZeroes(<span class="number">5</span>)</div></pre></td></tr></table></figure>
<h2 id="Leetcode-386-Lexicographical-Numbers"><a href="#Leetcode-386-Lexicographical-Numbers" class="headerlink" title="Leetcode 386. Lexicographical Numbers"></a>Leetcode 386. Lexicographical Numbers</h2><p>给出一个数字n，求 1 - n 这n个数字，要求是按照字典序排序。如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">n = 13</div><div class="line">result = [1,10,11,12,13,2,3,4,5,6,7,8,9]</div></pre></td></tr></table></figure>
<p>分析：可以发现，结果是从开头为1的开始，直到开头为9的，然后位数少的在前，位数多的在后。对每个数字都是如此。因此我们可以从 1 开始，先每次 <em>10 直到大于等于n停止，如果当前数字大于等于n，表示已经到顶了不能再增加了，可以用最低位开始 +1，其实也就是把该数字 +1。直到加到最后一位为0，此时我们应该优先处理没有最后一位的（比当前数字少最后一位的，根据前面的分析位数少的需要在前面）而这个多0的情况自然而然的会在少一位的情况下 </em>10 得到。因此不会丢数据。按照此规律进行n次操作，即可得到全部数字。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">lexicalOrder</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="keyword">int</span> cur = <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</div><div class="line">        list.add(cur);</div><div class="line">        <span class="keyword">if</span> (cur * <span class="number">10</span> &lt;= n) &#123;</div><div class="line">            cur *= <span class="number">10</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (cur &gt;= n) &#123;</div><div class="line">                cur /= <span class="number">10</span>;</div><div class="line">            &#125;</div><div class="line">            cur ++;</div><div class="line">            <span class="keyword">while</span> (cur % <span class="number">10</span> == <span class="number">0</span>) &#123;</div><div class="line">                cur /= <span class="number">10</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> list;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另一种思路是DFS，根据上面的分析我们可以发现，数字的排列是按照 1 - 9 进行的，我们把每一级看作一个位，那么向下一级扩展的过程就是增加一位并且这一位从 0-9 增加的一个过程，因此只需要对 1-9 分别做这个递归的DFS操作就可以得到全部解，参考 <a href="https://leetcode.com/xialanxuan1015" target="_blank" rel="external">xialanxuan1015</a> 的答案：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">lexicalOrder</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; ++i) &#123;</div><div class="line">        dfs(i, n, res); </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> n, List&lt;Integer&gt; res)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span> (cur &gt; n) &#123;</div><div class="line">        <span class="keyword">return</span> ;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        res.add(cur);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)&#123;</div><div class="line">            <span class="keyword">if</span>(<span class="number">10</span> * cur + i &gt; n)</div><div class="line">                <span class="keyword">return</span> ;</div><div class="line">            dfs(<span class="number">10</span> * cur + i, n, res);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Leetcode-390-Elimination-Game"><a href="#Leetcode-390-Elimination-Game" class="headerlink" title="Leetcode 390. Elimination Game"></a>Leetcode 390. Elimination Game</h1><p>给出一个 n 表示有 1-n n个有序数字。从第一个开始每次隔一个消除，先从左往右消除，再从右往左消除，求最后剩哪一个。</p>
<p>分析：设置一个步长 step 从1开始以 2^n 式增长表示每经过一轮之后的步长，然后用 head 表示当前状态从左向右数的第一个数字，使用一个变量 left 表示是从左往右还是从右往左，使用 remain 表示当前还剩下多少个数字，当只剩1个的时候返回那个数字。下面说规律：</p>
<ol>
<li>当从左向右删除的时候，删完以后剩余的第一个数字一定是 head + step</li>
<li>当从右向左删除的时候，如果当前剩余奇数个，删完以后是 head + step，否则还是 head</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span> left = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">int</span> head = <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> step = <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> remain = n;</div><div class="line">    <span class="keyword">while</span> (remain &gt; <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (left || remain % <span class="number">2</span> == <span class="number">1</span>) &#123;</div><div class="line">            head += step;</div><div class="line">        &#125;</div><div class="line">        remain /= <span class="number">2</span>;</div><div class="line">        step *= <span class="number">2</span>;</div><div class="line">        left = ! left;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> head;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Leetcode-396-Rotate-Function"><a href="#Leetcode-396-Rotate-Function" class="headerlink" title="Leetcode 396. Rotate Function"></a>Leetcode 396. Rotate Function</h1><p>给一个数列Bk，定义一个函数 <code>F(k) = 0 * Bk[0] + 1 * Bk[1] + ... + (n-1) * Bk[n-1]</code> ，求 F(k) 的最大值。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">A = [4, 3, 2, 6]</div><div class="line"></div><div class="line">F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25</div><div class="line">F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16</div><div class="line">F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23</div><div class="line">F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26</div><div class="line"></div><div class="line">So the maximum value of F(0), F(1), F(2), F(3) is F(3) = 26.</div></pre></td></tr></table></figure>
<p>这其实是一个数学题！！我们可以通过一个递推公式来避免每次都执行一遍上述运算。方法是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">F(k) = 0 * Bk[0] + 1 * Bk[1] + ... + (n-1) * Bk[n-1]</div><div class="line">F(k-1) = 0 * Bk-1[0] + 1 * Bk-1[1] + ... + (n-1) * Bk-1[n-1]</div><div class="line">       = 0 * Bk[1] + 1 * Bk[2] + ... + (n-2) * Bk[n-1] + (n-1) * Bk[0]</div><div class="line">两式相减，可以获得：</div><div class="line">F(k) - F(k-1) = Bk[1] + Bk[2] + ... + Bk[n-1] + (1-n)Bk[0]</div><div class="line">              = (Bk[0] + ... + Bk[n-1]) - nBk[0]</div><div class="line">              = sum - nBk[0]</div><div class="line">把 F(k-1) 移到右边，可以得到：</div><div class="line">F(k) = F(k-1) + sum - nBk[0]</div><div class="line">而 Bk[0] 是以 k 旋转后的第一个数字，写几个归纳一下可以发现 Bk[0] = A[(n - k) % n]，其实我们可以发现我们先计算出k=0的值来，然后让i从后往前走即可。</div><div class="line">所以可以简单的递推出所有和，从而寻找最大值</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxRotateFunction</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> allSum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> len = A.length;</div><div class="line">    <span class="keyword">int</span> F = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i ++) &#123;</div><div class="line">        F += i * A[i];</div><div class="line">        allSum += A[i];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> max = F;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i --) &#123;</div><div class="line">        F = F + allSum - len * A[i];</div><div class="line">        max = Math.max(F, max);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> max;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Leetcode-397-Integer-Replacement"><a href="#Leetcode-397-Integer-Replacement" class="headerlink" title="Leetcode 397. Integer Replacement"></a>Leetcode 397. Integer Replacement</h1><p>给一个数字n，可以用下列两种操作：如果n是偶数，除以2；如果n是奇数，可以选择加1或者减1。寻找让n变成1的最少操作次数。</p>
<p>分析</p>
<p>偶数的时候毫无疑问只能除以2，那么奇数的时候我们应该选择加还是减呢？</p>
<p>可以发现，如果一个数字在被加或者减以后变成一个偶数，这个偶数必然可以被2整除1次，如果能再被2整除一次，那么就能省掉一次加减操作。因此有下列考虑：如果加1能被4整除，那么加1，否则减1以尽快向1靠拢；注意3是个特殊情况，连续减两次比先加再除要少一次操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">integerReplacement</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (n == Integer.MAX_VALUE) <span class="keyword">return</span> <span class="number">32</span>; <span class="comment">//n = 2^31-1;</span></div><div class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (n &gt; <span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) n  /= <span class="number">2</span>;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">if</span> ( (n + <span class="number">1</span>) % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; (n != <span class="number">3</span>) ) n++;</div><div class="line">            <span class="keyword">else</span> n--;</div><div class="line">        &#125;</div><div class="line">        count++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> count;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另一种位运算其实也是基于这种思路，只不过把对4取余改成了右移操作检查，看倒数第二位是0还是1即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">integerReplacement</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> c = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (n != <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</div><div class="line">            n &gt;&gt;&gt;= <span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">3</span> || ((n &gt;&gt;&gt; <span class="number">1</span>) &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</div><div class="line">            --n;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            ++n;</div><div class="line">        &#125;</div><div class="line">        ++c;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> c;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Leetcode-400-Nth-Digit"><a href="#Leetcode-400-Nth-Digit" class="headerlink" title="Leetcode 400. Nth Digit"></a>Leetcode 400. Nth Digit</h1><p>将 0 - 2^31 这么多个数字从小到大排列后按照字符串的形式看，求第 n 个位置是数字几。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Input:</div><div class="line">3</div><div class="line"></div><div class="line">Output:</div><div class="line">3</div><div class="line"></div><div class="line">Input:</div><div class="line">11</div><div class="line"></div><div class="line">Output:</div><div class="line">0</div><div class="line">Explanation:</div><div class="line">1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... 第11位是0, 它属于数字10.</div></pre></td></tr></table></figure>
<p>这个题的思路主要是先找到第 n 位数所属的数字是几位数的范围，然后再找到他是 len 位数的哪个数字，最后找到他是这个数字的哪一位。可以看出，1位数有9个，2位数有90个，3位数有900个……</p>
<p>因此我们使用一个 <code>base = 9 * (10^k)</code> 来找到第 n 位数属于长度为 len 位的 len 值。</p>
<p>用一个 <code>start = 10^k</code> 找到 len 位数的第一个数字，使用 n 减去每次的数字数量最后剩下来的就是他在 len 长度数字的第 <code>(n - 1) / len</code> 个数字，至于为什么要减1，可以这么看：</p>
<p>假设 n = 6，len = 2，也即是两位数里的第六个字符，那么显然应该落在12的2上。而这个2的位置是起始位置10的1的位置多5，如果直接 n / len 会导致加到13的1上去，所以这里应该减1以计算距离。</p>
<p>最后是把该数字转换为字符串，寻找第 (n - 1) % len 个字符即可，减1的原因同样可以通过上例推出。</p>
<p>（注意 n 是第 n 个字符，如果数字长度为 len，那么显然通过 (n -1) / len 可以得到是哪个数字）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> len = <span class="number">1</span>;</div><div class="line">    <span class="keyword">long</span> base = <span class="number">9</span>;</div><div class="line">    <span class="keyword">int</span> start = <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (n &gt; len * base) &#123;</div><div class="line">        n -= len * base;</div><div class="line">        len += <span class="number">1</span>;</div><div class="line">        base *= <span class="number">10</span>;</div><div class="line">        start *= <span class="number">10</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    start += (n - <span class="number">1</span>) / len;</div><div class="line">    String s = Integer.toString(start);</div><div class="line">    <span class="keyword">return</span> Character.getNumericValue(s.charAt((n - <span class="number">1</span>) % len));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Leetcode-402-Remove-K-Digits"><a href="#Leetcode-402-Remove-K-Digits" class="headerlink" title="Leetcode 402. Remove K Digits"></a>Leetcode 402. Remove K Digits</h1><p>给出一个字符串表示的数字，给一个整数 k 表示从该数字中移除 k 位，求移除后所得到的最小的数字。</p>
<p>贪心算法。从左往右遍历数字，用一个栈存被选中的数字（因为你只能改最右边的数，所以用栈比较合适）如果一个新的数字比栈顶数字小，则替换并将 k-1，否则压栈。最后记得判断一下是不是栈空，栈空的话返回0</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">removeKdigits</span><span class="params">(String num, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (num.length() &lt;= k) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"0"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">char</span>[] stack = <span class="keyword">new</span> <span class="keyword">char</span>[num.length()];</div><div class="line">    <span class="keyword">int</span> finalLen = num.length() - k;</div><div class="line">    <span class="keyword">int</span> top = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length(); i ++) &#123;</div><div class="line">        <span class="keyword">char</span> c = num.charAt(i);</div><div class="line">        <span class="keyword">while</span> (top &gt; <span class="number">0</span> &amp;&amp; stack[top-<span class="number">1</span>] &gt; c &amp;&amp; k &gt; <span class="number">0</span>) &#123;</div><div class="line">            top --;</div><div class="line">            k --;</div><div class="line">        &#125;</div><div class="line">        stack[top] = c;</div><div class="line">        top ++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (start &lt; finalLen &amp;&amp; stack[start] == <span class="string">'0'</span>) &#123;</div><div class="line">        start ++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> start == finalLen ? <span class="string">"0"</span> : String.valueOf(stack, start, finalLen - start);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1>
<a href="/2018/04/21/素数问题/" title="素数相关问题">素数相关问题</a>
<a href="/2018/04/26/位运算/" title="位运算">位运算</a></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/leetcode/">leetcode</a></div></article><nav id="pagination"><div class="prev-post pull-left"><a href="/2018/05/01/单调栈/"><i class="fa fa-chevron-left">  </i><span>单调栈</span></a></div><div class="next-post pull-right"><a href="/2018/04/27/Leetcode 368. Largest Divisible Subset/"><span>Leetcode 368. Largest Divisible Subset</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">©2013 - 2018 By Nick</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span> |  </span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/fancybox.js"></script><script src="/js/sidebar.js"></script><script src="/js/copy.js"></script><script src="/js/fireworks.js"></script><script src="/js/transition.js"></script><script src="/js/scroll.js"></script><script src="/js/head.js"></script></body></html>